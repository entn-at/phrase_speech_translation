/*

fstprintpaths.cpp

traverses an fst and prints out all of the paths in that fst along with the costs.

output format is: WORD cost X.XX

where WORD is a sequence of characters accepted or generated by the fst AND X.XX 
is a floating point value representing the cost of traversing that structure.

author: chris taylor

OpenFst forum post title: "Natural code for printing all strings accepted by an FST?"
OpenFst forum post link: http://openfst.cs.nyu.edu/twiki/bin/view/Forum/FstForum#Natural_code_for_printing_all_st

author: Gaurav Kumar 

Changed to print paths using a vector : Can take care of multiple paths in a DFS manner
Added cli options to print input output or both

*/
#include "fstprintpaths.hpp"

using namespace openfsttools;

void fstprintpaths::printAllStrings(StdVectorFst& fst, SymbolTable& st, string& seqToSkip, int mode) 
{
        ProjectionEnum printInputOrOutput = PROJECT_INPUT;
        switch( mode ) {
          case 1:
            printInputOrOutput = PROJECT_OUTPUT;
            break;
          case 2:
            printInputOrOutput = PROJECT_BOTH;
            break;
        }
        vector<string> strVecInput;
        vector<string> strVecOutput;
        TropicalWeight tw(TropicalWeight::One());
        printAllStringsHelper(fst, st, fst.Start(), strVecInput, strVecOutput, tw, seqToSkip, printInputOrOutput);
}

void fstprintpaths::printAllStringsHelper(StdVectorFst& fst, SymbolTable& st, int state, vector<string>& strVecInput, vector<string>& strVecOutput, TropicalWeight cost, string& seqToSkip, ProjectionEnum printInputOrOutput) 
{
        if(fst.Final(state) != TropicalWeight::Zero())
        {
            string inputString = "";
            string outputString = "";
            for (vector<string>::iterator i = strVecInput.begin(); i != strVecInput.end(); ++i) {
                inputString += " " + (*i);
            }
            for (vector<string>::iterator i = strVecOutput.begin(); i != strVecOutput.end(); ++i) {
                outputString += " " + (*i);
            }
            switch (printInputOrOutput) {
                case PROJECT_INPUT:
                  cout << inputString;
                  break;
                case PROJECT_OUTPUT:
                  cout << outputString;
                  break;
                default:
                  cout << inputString << " ||| " << outputString << " ||| " << cost;
                  break;
            }
            cout << endl;
            return;
        }

        for(ArcIterator< StdVectorFst > iter(fst,state); !iter.Done(); iter.Next()) 
        {
            StdArc arc = iter.Value();

            string symbolInput = st.Find( arc.ilabel );
            string symbolOutput = st.Find( arc.olabel );

            if( symbolInput.compare( seqToSkip ) != 0 ) {
                strVecInput.push_back(symbolInput);
            }
            if( symbolOutput.compare( seqToSkip ) != 0 ) {
                strVecOutput.push_back(symbolOutput);
            }

            printAllStringsHelper(fst, st, arc.nextstate, strVecInput, strVecOutput, Times(cost, arc.weight.Value()), seqToSkip, printInputOrOutput);

            if( symbolInput.compare( seqToSkip ) != 0 ) {
                strVecInput.pop_back();
            }
            if( symbolOutput.compare( seqToSkip ) != 0 ) {
                strVecOutput.pop_back();
            }
        }
}


